# -*- coding: utf-8 -*-
"""CIFAR-10 Transfer Learning MobileNET

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/vinimuchulski/cifar-10-transfer-learning-mobilenet.90ea6831-c6b5-47b7-8d9a-a409bb748868.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250804/auto/storage/goog4_request%26X-Goog-Date%3D20250804T232557Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D822b3c7389c3b793bd65e02b9ee9965f9458b47e57037257ac634fa5b274f120adbd5107422675c3077207779ae37359a8f167396b0f0e31cf3e2bfc09e3f4c23f859548e9b83e6e220550c8d3839c89f4f7a3d04cd73a76f60b7b7f30786f0bc0b3b981fca86506f10ef57167eb97b81936483e97a7ea26e677a8a58c08cf6183991e2abe85eb1ac15c4de7d7ac8ab96c82a6d37936a26d9c1aca9f6d7ff2f9725c1d65413601e78fa324b39a29d7d092580969894c13a7dbc3db74bb15d7f92f66ed33dd051b71705796d68874127873dedfbaba54e155ba529bc4c0c8ec6d6ac8562e0fd73f081eb1517ed5bc26ced1ebbadaaca7ce7cef8e06d29f739f70
"""

import tensorflow as tf
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Input, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
import numpy as np

INPUT_SHAPE = (96, 96, 3)
NUM_CLASSES = 10
LEARNING_RATE = 0.0001
BATCH_SIZE = 32
INITIAL_EPOCHS = 10
FINE_TUNE_EPOCHS = 10
FINE_TUNE_AT = 100
H5_MODEL_PATH = "cifar10_mobilenetv2_finetuned.h5"
TFLITE_MODEL_PATH = "cifar10_mobilenetv2_finetuned.tflite"

def load_and_preprocess_data():
    (x_train, y_train), (x_test, y_test) = cifar10.load_data()

    y_train = to_categorical(y_train, NUM_CLASSES)
    y_test = to_categorical(y_test, NUM_CLASSES)

    def preprocess_image(image, label):
        image = tf.cast(image, tf.float32)
        image = tf.image.resize(image, (INPUT_SHAPE[0], INPUT_SHAPE[1]))
        image = tf.keras.applications.mobilenet_v2.preprocess_input(image)
        return image, label

    train_ds = tf.data.Dataset.from_tensor_slices((x_train, y_train))
    train_ds = (
        train_ds.shuffle(buffer_size=1024)
        .map(preprocess_image, num_parallel_calls=tf.data.AUTOTUNE)
        .batch(BATCH_SIZE)
        .prefetch(tf.data.AUTOTUNE)
    )

    test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test))
    test_ds = (
        test_ds.map(preprocess_image, num_parallel_calls=tf.data.AUTOTUNE)
        .batch(BATCH_SIZE)
        .prefetch(tf.data.AUTOTUNE)
    )
    return train_ds, test_ds

def build_model():
    base_model = MobileNetV2(input_shape=INPUT_SHAPE,
                             include_top=False,
                             weights='imagenet')
    base_model.trainable = False

    inputs = Input(shape=INPUT_SHAPE)
    x = base_model(inputs, training=False)
    x = GlobalAveragePooling2D()(x)
    x = Dropout(0.2)(x)
    outputs = Dense(NUM_CLASSES, activation='softmax')(x)
    model = Model(inputs, outputs)
    return model, base_model

def compile_and_train(model, train_ds, test_ds):
    model.compile(optimizer=Adam(learning_rate=LEARNING_RATE),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    history = model.fit(train_ds,
                        epochs=INITIAL_EPOCHS,
                        validation_data=test_ds)
    return history

def fine_tune_model(model, base_model, train_ds, test_ds):
    base_model.trainable = True

    for layer in base_model.layers[:FINE_TUNE_AT]:
        layer.trainable = False

    model.compile(optimizer=Adam(learning_rate=LEARNING_RATE / 10),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])

    total_epochs = INITIAL_EPOCHS + FINE_TUNE_EPOCHS
    history_fine = model.fit(train_ds,
                             epochs=total_epochs,
                             initial_epoch=INITIAL_EPOCHS,
                             validation_data=test_ds)
    return history_fine

def save_models(model):
    model.save(H5_MODEL_PATH)
    print(f"Model saved to {H5_MODEL_PATH}")

    converter = tf.lite.TFLiteConverter.from_keras_model(model)
    converter.optimizations = [tf.lite.Optimize.DEFAULT]
    tflite_model = converter.convert()

    with open(TFLITE_MODEL_PATH, 'wb') as f:
        f.write(tflite_model)
    print(f"Model saved to {TFLITE_MODEL_PATH}")

def test_tflite_accuracy(model_path):
    (_, _), (x_test, y_test) = cifar10.load_data()

    interpreter = tf.lite.Interpreter(model_path=model_path)
    interpreter.allocate_tensors()

    input_details = interpreter.get_input_details()[0]
    output_details = interpreter.get_output_details()[0]

    height = input_details['shape'][1]
    width = input_details['shape'][2]

    correct_predictions = 0
    total_images = len(x_test)

    for i in range(total_images):
        image = x_test[i]
        image_expanded = np.expand_dims(image, axis=0)
        image_resized = tf.image.resize(image_expanded, [height, width])
        image_preprocessed = tf.keras.applications.mobilenet_v2.preprocess_input(image_resized)

        interpreter.set_tensor(input_details['index'], image_preprocessed)
        interpreter.invoke()

        output_data = interpreter.get_tensor(output_details['index'])
        predicted_label = np.argmax(output_data)
        true_label = y_test[i][0]

        if predicted_label == true_label:
            correct_predictions += 1

    accuracy = (correct_predictions / total_images) * 100
    print(f"\nTFLite model accuracy: {accuracy:.2f}% ({correct_predictions}/{total_images})")

train_ds, test_ds = load_and_preprocess_data()
model, base_model = build_model()

print("--- Starting Initial Training (Transfer Learning) ---")
compile_and_train(model, train_ds, test_ds)

loss, accuracy = model.evaluate(test_ds)
print(f"\nTest Accuracy (Transfer Learning): {accuracy * 100:.2f}%")

model.summary()

print("\n--- Starting Fine-Tuning ---")
fine_tune_model(model, base_model, train_ds, test_ds)

loss, accuracy = model.evaluate(test_ds)
print(f"\nFinal Test Accuracy: {accuracy * 100:.2f}%")

save_models(model)

test_tflite_accuracy(TFLITE_MODEL_PATH)

"""# TensorFlow Lite INT8"""

import tensorflow as tf
import numpy as np
import os

H5_MODEL_PATH = "cifar10_mobilenetv2_finetuned.h5"
TFLITE_INT8_MODEL_PATH = "cifar10_mobilenetv2_finetuned_int8.tflite"
INPUT_SHAPE = (96, 96, 3)

def representative_dataset_gen():
    (x_train, _), _ = tf.keras.datasets.cifar10.load_data()
    for i in range(100):
        image = x_train[i].astype(np.float32)
        image = tf.image.resize(image, (INPUT_SHAPE[0], INPUT_SHAPE[1]))
        image = tf.keras.applications.mobilenet_v2.preprocess_input(image)
        image = np.expand_dims(image, axis=0)
        yield [image]

converter = tf.lite.TFLiteConverter.from_keras_model(tf.keras.models.load_model(H5_MODEL_PATH))
converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.representative_dataset = representative_dataset_gen
converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]
converter.inference_input_type = tf.int8
converter.inference_output_type = tf.int8

tflite_model_quant = converter.convert()

with open(TFLITE_INT8_MODEL_PATH, 'wb') as f:
    f.write(tflite_model_quant)

print(f"INT8 quantized model saved to: {TFLITE_INT8_MODEL_PATH}")
print(f"Original model size: {os.path.getsize(H5_MODEL_PATH) / 1024:.2f} KB")
print(f"INT8 model size: {os.path.getsize(TFLITE_INT8_MODEL_PATH) / 1024:.2f} KB")

import tensorflow as tf
import numpy as np

TFLITE_INT8_MODEL_PATH = "cifar10_mobilenetv2_finetuned_int8.tflite"

def test_tflite_int8_accuracy(model_path):
    (_, _), (x_test, y_test) = tf.keras.datasets.cifar10.load_data()

    interpreter = tf.lite.Interpreter(model_path=model_path)
    interpreter.allocate_tensors()

    input_details = interpreter.get_input_details()[0]
    output_details = interpreter.get_output_details()[0]

    input_scale, input_zero_point = input_details["quantization"]
    output_scale, output_zero_point = output_details["quantization"]

    height = input_details['shape'][1]
    width = input_details['shape'][2]

    correct_predictions = 0
    total_images = len(x_test)

    for i in range(total_images):
        image = x_test[i]
        image_expanded = np.expand_dims(image, axis=0)
        image_resized = tf.image.resize(image_expanded, [height, width])
        image_preprocessed = tf.keras.applications.mobilenet_v2.preprocess_input(image_resized)

        image_quantized = (image_preprocessed / input_scale) + input_zero_point
        image_quantized = tf.cast(image_quantized, dtype=input_details["dtype"])

        interpreter.set_tensor(input_details['index'], image_quantized)
        interpreter.invoke()

        output_data = interpreter.get_tensor(output_details['index'])
        output_data_dequantized = (output_data.astype(np.float32) - output_zero_point) * output_scale

        predicted_label = np.argmax(output_data_dequantized)
        true_label = y_test[i][0]

        if predicted_label == true_label:
            correct_predictions += 1

    accuracy = (correct_predictions / total_images) * 100
    print(f"\nINT8 TFLite model accuracy: {accuracy:.2f}% ({correct_predictions}/{total_images})")

test_tflite_int8_accuracy(TFLITE_INT8_MODEL_PATH)